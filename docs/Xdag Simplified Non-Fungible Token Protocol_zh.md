# Xdag Simplified Non-Fungible Token Protocol （XSNFTP, Xdag 简化非同质化通证协议）

## 1、简要

XSNFTP 是通过在交易的备注中填写特定内容，将文件铸造为 Xdag 链上 NFT 的协议。被填写了备注的交易的接收地址，为这个 NFT 的地址。一个 NFT 的地址会接收有多笔含有不同备注的转账，有四个类型如下：

1. 铸造头声明：包含 NFT 铸造者地址哈希。一切 NFT 相关操作在铸造头声明后方有效。若存在多个，仅第一个有效。

2. 铸造内容摘要：包含文件总字符数（16进制下）与 NFT 名称。若存在多个，仅第一个有效。

3. 声明铸造页：包含该铸造页的页数与文件内容。若存在相同页数，仅第一个有效。

4. 转让：包含接收者地址哈希。

需要注意的是（你可以在 decoder.py 的 decode_all_remarks() 函数中找到以下逻辑）：

1. 声明铸造头前一切操作皆无效。

2. 铸造内容摘要与声明铸造页仅铸造者发起的有效。

3. 铸造内容摘要与声明铸造页没有顺序。即声明铸造页可以出现在铸造内容摘要前，且声明铸造页中页数不必升序排列。

4. 转账仅所有者发起的有效。

5. 铸造头声明后，转账即有效。且转账后**铸造者**仍可继续铸造。

## 2、具体实现

一段对于 XSNFTP 有效的备注，是一段长为 64 个字符的 base64 编码，其解码后有 24 个 16 进制位。

1. 铸造头声明
   
   | XSNFTP识别码 | 操作码: 声明铸造头 | 22位铸造者地址哈希【示例】                                                       |
   |:---------:|:----------:| -------------------------------------------------------------------- |
   | 0         | 0          | 14 66 6c 6f 77 65 72 2e 70 6e 67 00 08 2e 70 6e 67 89 50 4e 47 0d 0a |
   
   哈希生成代码于 ./sha256_22 中。

2. 铸造内容摘要
   
   | XSNFTP识别码 | 操作码：铸造内容摘要 | 文件总字符数（16进制）【示例】 | 32位 NFT 名称 (不足 0 填充)【示例】                          |
   |:---------:|:----------:|:----------------:|:----------------------------------------------- |
   | 0         | 1          | 0000ab           | 74 65 73 74 00 00 00 00 00 00 00 00 00 00 00 00 |

3. 声明铸造页
   
   | XSNFTP识别码 | 操作码：声明铸造页 | 页数【示例】 | 内容 (由文件内容编码后切片)【示例】                                                  |
   |:---------:|:---------:|:------:|:-------------------------------------------------------------------- |
   | 0         | 2         | 0000   | 14 66 6c 6f 77 65 72 2e 70 6e 67 00 08 2e 70 6e 67 89 50 4e 47 0d 0a |

4. 转让
   
   | XSNFTP识别码 | 操作码：转让 | 接收者地址Hash【示例】                                                         |
   |:---------:|:------:| -------------------------------------------------------------------- |
   | 0         | 3      | 14 66 6c 6f 77 65 72 2e 70 6e 67 00 08 2e 70 6e 67 89 50 4e 47 0d 0a |

## 3、文件编码

如下实现文件编码，可在 encoder.py 中找到。

```python
def file_to_hex(file_path):

    # 获取文件名和扩展名
    file_name = os.path.basename(file_path)
    file_extension = os.path.splitext(file_name)[1]  # 获取文件扩展名

    with open(file_path, 'rb') as file:
        file_content = file.read()

    hex_file_name = binascii.hexlify(file_name.encode()).decode()
    hex_file_extension = binascii.hexlify(file_extension.encode()).decode()
    hex_file_content = binascii.hexlify(file_content).decode()

    # 组合成一个完整的16进制字符串，格式为：文件名长度 + 文件名 + 扩展名长度 + 扩展名 + 文件内容
    hex_string = f"{len(hex_file_name):04X}{hex_file_name}{len(hex_file_extension):04X}{hex_file_extension}{hex_file_content}"
    return hex_string
```
